<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tests to evaluate · BioFindr.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://tmichoel.github.io/BioFindr.jl/testLLR/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BioFindr.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../inference/">General inference algorithm</a></li><li><a class="tocitem" href="../realLLR/">Likelihood ratio tests</a></li><li><a class="tocitem" href="../randomLLR/">Null distributions of the LLRs</a></li><li><a class="tocitem" href="../posteriorprobs/">Bayesian inference of posterior probabilities</a></li><li class="is-active"><a class="tocitem" href>Tests to evaluate</a><ul class="internal"><li><a class="tocitem" href="#Coexpression-analysis"><span>Coexpression analysis</span></a></li><li><a class="tocitem" href="#Association-analysis"><span>Association analysis</span></a></li><li><a class="tocitem" href="#Causal-inference"><span>Causal inference</span></a></li><li><a class="tocitem" href="#Bipartite-causal-inference"><span>Bipartite causal inference</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><a class="tocitem" href="../listfunctions/">List of functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tests to evaluate</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tests to evaluate</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tmichoel/BioFindr.jl/blob/main/docs/src/testLLR.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tests-to-evaluate"><a class="docs-heading-anchor" href="#Tests-to-evaluate">Tests to evaluate</a><a id="Tests-to-evaluate-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-to-evaluate" title="Permalink"></a></h1><p>Based on the six <a href="../realLLR/#Likelihood-ratio-tests">Likelihood ratio tests</a>, we use the following tests and test combinations for the inference of genetic regulations:</p><h2 id="Coexpression-analysis"><a class="docs-heading-anchor" href="#Coexpression-analysis">Coexpression analysis</a><a id="Coexpression-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Coexpression-analysis" title="Permalink"></a></h2><p>The correlation test is introduced as a benchmark, against which we can compare other methods involving genotype information. Pairwise correlation is a simple measure for the probability of two genes being functionally related either through direct or indirect regulation, or through coregulation by a third factor. Bayesian inference additionally considers different gene roles. Its predicted posterior probability for regulation is <span>$P_0$</span>.</p><p>Correlation analysis can be performed by calling <code>findr</code> with one argument, a matrix or dataframe of gene expression values:</p><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(X::Matrix{T}; cols=[], method=&quot;moments&quot;, combination=&quot;none&quot;) where T&lt;:AbstractFloat</code></pre><p>Compute posterior probabilities for nonzero pairwise correlations between columns of input matrix <code>X</code>. The probabilities are directed (asymmetric) in the sense that they are estimated from a column-specific background distribution.</p><p>The optional parameter <code>cols</code> (vector of integers) determines whether we consider all columns of <code>X</code> as source nodes (<code>cols=[]</code>, default), or only a subset of columns determined by the indices in the vector <code>cols</code>.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>combination</code> determines whether the output must be symmetrized. Possible values are <code>none</code> (default), <code>prod</code>, <code>mean</code>, or <code>anti</code>. If the optional parameter <code>cols</code> is non-empty, symmetrization makes no sense and an error will be thrown unless <code>combination=&quot;none&quot;</code>.</p><p>See also <a href="#BioFindr.findr-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame"><code>findr(::DataFrame)</code></a>, <a href="../utils/#BioFindr.symprobs"><code>symprobs</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame" href="#BioFindr.findr-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(dX::T; colnames=[], method=&quot;moments&quot;, FDR=1.0, sorted=true, combination=&quot;none&quot;) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX))</code> when the input <code>dX</code> is in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code>, (Posterior) <code>Probability</code>, and <code>qvalue</code> columns.</p><p>The optional parameter <code>colnames</code> (vector of strings) determines whether we consider all columns of <code>dX</code> as source nodes (<code>colnames=[]</code>, default), or only a subset of columns determined by the variable names in the vector <code>colnames</code>.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX</code>) (<code>sorted=false</code>)</p><p>The optional parameter <code>combination</code> determines whether the output must be symmetrized. Possible values are <code>none</code> (default), <code>prod</code>, <code>mean</code>, or <code>anti</code>. If the optional parameter <code>colnames</code> is non-empty, symmetrization makes no sense and an error will be thrown unless <code>combination=&quot;none&quot;</code>.</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::Matrix)</code></a>, <a href="../utils/#BioFindr.symprobs"><code>symprobs</code></a>, <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L80-L96">source</a></section></article><h2 id="Association-analysis"><a class="docs-heading-anchor" href="#Association-analysis">Association analysis</a><a id="Association-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Association-analysis" title="Permalink"></a></h2><p>The secondary linkage test is introduced to test association between genetic variants and gene expression levels, and can be used more generally to analyze differential expression of genes across groups defined by any kind of categorical variable. Its predicted posterior probability for differential expression is <span>$P_2$</span>.</p><p>Association analysis can be performed by calling <code>findr</code> with two arguments, matrices or dataframes of continuous gene expression values and categorical genotype or more general grouping values, respectively:</p><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Array{S}}} where {T&lt;:AbstractFloat, S&lt;:Integer}" href="#BioFindr.findr-Union{Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Array{S}}} where {T&lt;:AbstractFloat, S&lt;:Integer}"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(X::Matrix{T},G::Array{S}; method=&quot;moments&quot;) where {T&lt;:AbstractFloat, S&lt;:Integer}</code></pre><p>Compute posterior probabilities for nonzero differential expression of colunns of input matrix <code>X</code> across groups defined by one or more categorical variables (columns of <code>G</code>).</p><p>Return a matrix of size ncols(X) x ncols(G)</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::DataFrame,::DataFrame)</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>G</code> is currently assumed to be an array (vector or matrix) of integers. CategoricalArrays will be supported in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L141-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{T}, Tuple{T, T}} where T&lt;:DataFrames.AbstractDataFrame" href="#BioFindr.findr-Union{Tuple{T}, Tuple{T, T}} where T&lt;:DataFrames.AbstractDataFrame"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(dX::T, dG::T; method=&quot;moments&quot;, FDR=1.0, sorted=true) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX), Matrix(dG))</code> when the inputs <code>dX</code> and <code>dG</code> are in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code> (Posterior) <code>Probability</code>, and <code>qvalue</code> columns.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX</code>) (<code>sorted=false</code>)</p><p>Note that depending on the type of <code>Matrix(dG)</code>, different matrix-based methods are called. If <code>Matrix(dG)</code> consists of Floats, posterior probabilities for nonzero pairwise correlations between the variables in <code>dG</code> and variables in <code>dX</code> are computed. If <code>Matrix(dG)</code> consists of integers, posterior probabilities for nonzero differential expression of variables in <code>dX</code> across groups defined by the variables in <code>dG</code> are computed</p><p>See also [<code>findr(::Matrix,::Array)</code>], <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L168-L182">source</a></section></article><h2 id="Causal-inference"><a class="docs-heading-anchor" href="#Causal-inference">Causal inference</a><a id="Causal-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Causal-inference" title="Permalink"></a></h2><h3 id="Mediation"><a class="docs-heading-anchor" href="#Mediation">Mediation</a><a id="Mediation-1"></a><a class="docs-heading-anchor-permalink" href="#Mediation" title="Permalink"></a></h3><p>The traditional causal inference test, as explained in <sup class="footnote-reference"><a id="citeref-Chen2007" href="#footnote-Chen2007">[Chen2007]</a></sup>, suggested that the regulatory relation <span>$E\to A\to B$</span>can be confirmed with the combination of three separate tests: <span>$E$</span> regulates <span>$A$</span>, <span>$E$</span> regulates <span>$B$</span>, and <span>$E$</span> only regulates <span>$B$</span> through <span>$A$</span> (i.e. <span>$E$</span> and <span>$B$</span> become independent when conditioning on <span>$A$</span>). They correspond to the primary, secondary, and conditional independence tests respectively. The regulatory relation <span>$E\to A\to B$</span> is regarded positive only when all three tests return positive. The three tests filter the initial hypothesis space of all possible relations between <span>$E$</span>, <span>$A$</span>, and <span>$B$</span>, sequentially to <span>$E\to A$</span> (primary test), <span>$E\to A \wedge E\to B$</span> (secondary test), and <span>$E\to A\to B \wedge$</span> (no confounder for <span>$A$</span> and <span>$B$</span>) (conditional independence test). The resulting test is stronger than <span>$E\to A\to B$</span> by disallowing confounders for A and B. So its probability can be broken down as</p><p class="math-container">\[P_{\text{med}} \equiv P_1P_2P_3\]</p><p>BioFindr expects a set of significant eQTLs and their associated genes as input, and therefore <span>$P_1=1$</span> is assured and not calculated separately in BioFindr. Note that <span>$P_{\text{med}}$</span> is the estimated local precision, i.e. the probability that tests 2 and 3 are both true. Correspondinly, its local FDR (the probability that one of them is false) is <span>$1-P_{\text{med}}$</span>.</p><h3 id="Instrumental-variables"><a class="docs-heading-anchor" href="#Instrumental-variables">Instrumental variables</a><a id="Instrumental-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Instrumental-variables" title="Permalink"></a></h3><p>The pleiotropy test is introduced to test if an <span>$E\to B$</span> association is not independent of the <span>$E\to A$</span> association, that is, if an independent pleiotropic effect of <span>$E$</span> on both genes can be excluded. If <span>$E$</span> regulates <span>$A$</span> (is a cis-eQTL for <span>$A$</span>), and <span>$E$</span> regulates <span>$B$</span>, and  <span>$B$</span> and <span>$A$</span> are not independent given <span>$E$</span>, then we can regard <span>$E$</span> as a proxy or instrumental variable for <span>$A$</span> and infer a regulatory relation <span>$E\to A\to B$</span> from the <span>$E\to B$</span> association. The three tests verify the hypothesis that <span>$B \leftarrow E \to A \wedge \lnot(A ⫫ B | E)$</span>, a superset of <span>$E\to A\to B$</span>.  Its probability can be broken down as</p><p class="math-container">\[P_{\text{IV}} \equiv P_1P_2P_5\]</p><p>As before, <span>$P_1=1$</span> is assured and not calculated separately in BioFindr. <span>$P_{\text{IV}}$</span> is again the estimated local precision, i.e. the probability that tests 2 and 5 are both true, and its local FDR (the probability that one of them is false) is <span>$1-P_{\text{IV}}$</span>.</p><h3 id="Relevance"><a class="docs-heading-anchor" href="#Relevance">Relevance</a><a id="Relevance-1"></a><a class="docs-heading-anchor-permalink" href="#Relevance" title="Permalink"></a></h3><p>The relevance test is introduced to address weak interactions that are undetectable by the secondary test from existing data (<span>$P_2$</span> close to 0). This term still grants higher-than-null significance to weak interactions, and verifies that <span>$E\to A \wedge (E\to B \vee A - B)$</span>, also a superset of <span>$E\to A\to B$</span>. Its probability can be broken down as</p><p class="math-container">\[P_{\text{relev}} \equiv P_1P_4\]</p><p>The original Findr paper proposed to combine the instrumental variable and relevance tests in a novel test whose probability can be broken down as</p><p class="math-container">\[P_{\text{orig}} \equiv \frac{1}{2} P_1 \bigl( P_4 + P_2P_5) = \frac{1}{2}\bigl( P_{\text{relev}} + P_{\text{IV}} \bigr)\]</p><p>In the extreme undetectable limit where <span>$P_2 = 0$</span> but <span>$P_4 \neq 0$</span>, the novel test automatically reduces to one half of the relevance test, which assumes equal probability of either direction and assigns half of the relevance test probability to <span>$A \to B$</span>.</p><p>The composite design of the novel test aims not to miss any genuine regulation whilst distinguishing the full spectrum of possible interactions. When the signal level is too weak for tests 2 and 5, we expect <span>$P_4$</span> to still provide distinguishing power better than random predictions. When the interaction is strong, <span>$P_2 P_5$</span> is then able to pick up true targets regardless of the existence of hidden confounders.</p><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><p>Causal inference can be performed by calling <code>findr</code> with three arguments, matrices or dataframes of gene expression and genotype values, and a mapping of matching <span>$(E,A)$</span> pairs; the preferred test can be set through the <code>combination</code> parameter:</p><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{R}, Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Matrix{S}, Matrix{R}}} where {T&lt;:AbstractFloat, S&lt;:Integer, R&lt;:Integer}" href="#BioFindr.findr-Union{Tuple{R}, Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Matrix{S}, Matrix{R}}} where {T&lt;:AbstractFloat, S&lt;:Integer, R&lt;:Integer}"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(X::Matrix{T},G::Matrix{S},pairGX::Matrix{S}; method=&quot;moments&quot;, combination=&quot;none&quot;) where {T&lt;:AbstractFloat, S&lt;:Integer}</code></pre><p>Compute posterior probabilities for nonzero causal relations between columns of input matrix <code>X</code>. The probabilities are estimated for relations going from a subset of columns of <code>X</code> that have a (discrete) instrumental variable in input matrix <code>G</code> to all columns of <code>X</code>, while excluding self-interactions (given default value 1). The matching between columns of <code>X</code> and columns of <code>G</code> is given by <code>pairGX</code>, a two-column array where the first column corresponds to a column index in <code>G</code> and the second to a column index in <code>X</code>.</p><p>Posterior probabilities are computed for the following tests</p><ul><li>Test 2 (<strong>Linkage test</strong>) </li><li>Test 3 (<strong>Mediation test</strong>)</li><li>Test 4 (<strong>Relevance test</strong>)</li><li>Test 5 (<strong>Pleiotropy test</strong>)</li></ul><p>which can be combined into the mediation test (<span>$P_2 P_3$</span>; <code>combination=&quot;mediation&quot;</code>), the instrumental variable or non-independence test (<span>$P_2 P_5$</span>; <code>combination=&quot;IV&quot;</code>), or BioFindr&#39;s original combination (<span>$\frac{1}{2}(P_2 P_5 + P_4)$</span>; <code>combination=&quot;orig&quot;</code>). By default, individual probability matrices for all tests are returned (<code>combination=&quot;none&quot;</code>).</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>If <code>combination=&quot;none&quot;</code>, then the output has size ncols(X) x 4 x ncols(G), where the middle index indexes the tests, and otherwise the output has size ncols(X) x ncols(G). </p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::DataFrame,::DataFrame,::DataFrame)</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>G</code> is currently assumed to be an array (vector or matrix) of integers. I intend to use CategoricalArrays in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L194-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:DataFrames.AbstractDataFrame" href="#BioFindr.findr-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:DataFrames.AbstractDataFrame"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(dX::T, dG::T, dE::T; colX=2, colG=1, method=&quot;moments&quot;, combination=&quot;IV&quot;, FDR=1.0, sorted=true) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX), Matrix(dG), pairGX)</code> when the inputs are in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code> (Posterior) <code>Probability</code>, and <code>qvalue</code> columns. When DataFrames are used, only combined posterior probabilities can be returned (<code>combination=&quot;IV&quot;</code> (default), <code>&quot;mediation&quot;</code>, or <code>&quot;orig&quot;</code>).</p><p>The input dataframes are:</p><ul><li><code>dX</code> - DataFrame with expression data, columns are genes</li><li><code>dG</code> - DataFrame with genotype data, columns are variants (SNPs)</li><li><code>dE</code> - DataFrame with eQTL results, must contain columns with gene and SNP IDs that can be mapped to column names in <code>dX</code> and <code>dG</code>, respectively</li><li><code>colG</code> - name or number of variant ID column in <code>dE</code>, default 1</li><li><code>colX</code> - name or number of gene ID column in <code>dE</code>, default 2</li></ul><p>The numeric mapping between column indices in <code>Matrix(dG)</code> and <code>Matrix(dX)</code> is obtained from these inputs using the <a href="../utils/#BioFindr.getpairs"><code>getpairs</code></a> function.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX</code>) (<code>sorted=false</code>)</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::Matrix,::Array,::Matrix)</code></a>, <a href="../utils/#BioFindr.getpairs"><code>getpairs</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>, <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L235-L257">source</a></section></article><h2 id="Bipartite-causal-inference"><a class="docs-heading-anchor" href="#Bipartite-causal-inference">Bipartite causal inference</a><a id="Bipartite-causal-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Bipartite-causal-inference" title="Permalink"></a></h2><p>In the general case, we assume that there is one set of genes, of which the set of <span>$A$</span>-genes (genes with matching instrument <span>$E$</span>) is a subset, and that all possible directed regulations are tested. In some situations we are instead searching for a bipartite network from one set of potential causal factors (e.g. micro-RNAs) to another set of potential targets (e.g. protein-coding genes). In this case, causal inference can be performed by calling <code>findr</code> with four arguments that include separate matrices or dataframes of expression values for the potential causes and targets:</p><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{R}, Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Array{T}, Array{S}, Matrix{R}}} where {T&lt;:AbstractFloat, S&lt;:Integer, R&lt;:Integer}" href="#BioFindr.findr-Union{Tuple{R}, Tuple{S}, Tuple{T}, Tuple{Matrix{T}, Array{T}, Array{S}, Matrix{R}}} where {T&lt;:AbstractFloat, S&lt;:Integer, R&lt;:Integer}"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(X1::Matrix{T},X2::Array{T},G::Array{S},pairGX::Matrix{R}; method=&quot;moments&quot;, combination=&quot;none&quot;)  where {T&lt;:AbstractFloat, S&lt;:Integer}</code></pre><p>Compute posterior probabilities for nonzero causal relations from columns of input matrix <code>X2</code> to columns of input matrix <code>X1</code>. The probabilities are estimated for a subset of columns of <code>X2</code> that have a (discrete) instrumental variable in input matrix <code>G</code>. The matching between columns of <code>X2</code> and columns of <code>G</code> is given by <code>pairGX</code>, a two-column array where the first column corresponds to a column index in <code>G</code> and the second to a column index in <code>X2</code>.</p><p>Posterior probabilities are computed for the following tests</p><ul><li>Test 2 (<strong>Linkage test</strong>) </li><li>Test 3 (<strong>Mediation test</strong>)</li><li>Test 4 (<strong>Relevance test</strong>)</li><li>Test 5 (<strong>Pleiotropy test</strong>)</li></ul><p>which can be combined into the mediation test (<span>$P_2 P_3$</span>; <code>combination=&quot;mediation&quot;</code>), the instrumental variable or non-independence test (<span>$P_2 P_5$</span>; <code>combination=&quot;IV&quot;</code>), or BioFindr&#39;s original combination (<span>$\frac{1}{2}(P_2 P_5 + P_4)$</span>; <code>combination=&quot;orig&quot;</code>). By default, individual probability matrices for all tests are returned (<code>combination=&quot;none&quot;</code>).</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>If <code>combination=&quot;none&quot;</code>, then the output has size ncols(X1) x 4 x ncols(X2), where the middle index indexes the tests, and otherwise the output has size ncols(X1) x ncols(X2).</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::DataFrame,::DataFrame,::DataFrame,::DataFrame)</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>G</code> is currently assumed to be an array (vector or matrix) of integers. I intend to use CategoricalArrays in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L276-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr-Union{Tuple{T}, NTuple{4, T}} where T&lt;:DataFrames.AbstractDataFrame" href="#BioFindr.findr-Union{Tuple{T}, NTuple{4, T}} where T&lt;:DataFrames.AbstractDataFrame"><code>BioFindr.findr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findr(dX1::T, dX2::T, dG::T, dE::T; colG=1, colX=2, method=&quot;moments&quot;, combination=&quot;IV&quot;, FDR=1.0, sorted=true) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX1), Matrix(dX2), Matrix(dG), pairGX2)</code> when the inputs <code>dX1</code>, <code>dX2</code>, and <code>dG</code> are in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code>, (Posterior) <code>Probability</code>, and <code>qvalue</code> columns. When DataFrames are used, only combined posterior probabilities can be returned (<code>combination=&quot;IV&quot;</code> (default), <code>&quot;mediation&quot;</code>, or <code>&quot;orig&quot;</code>).</p><p>The numeric mapping between column indices in <code>Matrix(dG)</code> and <code>Matrix(dX2)</code> is obtained from the DataFrame inputs using the <a href="../utils/#BioFindr.getpairs"><code>getpairs</code></a> function.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX2</code>) (<code>sorted=false</code>)</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::Matrix,::Array,::Array,::Matrix)</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>, <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L319-L333">source</a></section></article><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>A summary of all possible calls to the <code>findr</code> function:</p><article class="docstring"><header><a class="docstring-binding" id="BioFindr.findr" href="#BioFindr.findr"><code>BioFindr.findr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findr(X::Matrix{T}; cols=[], method=&quot;moments&quot;, combination=&quot;none&quot;) where T&lt;:AbstractFloat</code></pre><p>Compute posterior probabilities for nonzero pairwise correlations between columns of input matrix <code>X</code>. The probabilities are directed (asymmetric) in the sense that they are estimated from a column-specific background distribution.</p><p>The optional parameter <code>cols</code> (vector of integers) determines whether we consider all columns of <code>X</code> as source nodes (<code>cols=[]</code>, default), or only a subset of columns determined by the indices in the vector <code>cols</code>.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>combination</code> determines whether the output must be symmetrized. Possible values are <code>none</code> (default), <code>prod</code>, <code>mean</code>, or <code>anti</code>. If the optional parameter <code>cols</code> is non-empty, symmetrization makes no sense and an error will be thrown unless <code>combination=&quot;none&quot;</code>.</p><p>See also <a href="#BioFindr.findr-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame"><code>findr(::DataFrame)</code></a>, <a href="../utils/#BioFindr.symprobs"><code>symprobs</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L49-L61">source</a></section><section><div><pre><code class="language-julia hljs">findr(dX::T; colnames=[], method=&quot;moments&quot;, FDR=1.0, sorted=true, combination=&quot;none&quot;) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX))</code> when the input <code>dX</code> is in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code>, (Posterior) <code>Probability</code>, and <code>qvalue</code> columns.</p><p>The optional parameter <code>colnames</code> (vector of strings) determines whether we consider all columns of <code>dX</code> as source nodes (<code>colnames=[]</code>, default), or only a subset of columns determined by the variable names in the vector <code>colnames</code>.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX</code>) (<code>sorted=false</code>)</p><p>The optional parameter <code>combination</code> determines whether the output must be symmetrized. Possible values are <code>none</code> (default), <code>prod</code>, <code>mean</code>, or <code>anti</code>. If the optional parameter <code>colnames</code> is non-empty, symmetrization makes no sense and an error will be thrown unless <code>combination=&quot;none&quot;</code>.</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::Matrix)</code></a>, <a href="../utils/#BioFindr.symprobs"><code>symprobs</code></a>, <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L80-L96">source</a></section><section><div><pre><code class="nohighlight hljs">findr(X1::Matrix{T}, X2::Matrix{T}; method=&quot;moments&quot;) where T&lt;:AbstractFloat</code></pre><p>Compute posterior probabilities for nonzero pairwise correlations between columns of input matrices <code>X1</code> and <code>X2</code>. The probabilities are directed (asymmetric) from the columns of <code>X2</code> to the columns of <code>X1</code> in the sense that they are estimated from a column-specific background distribution for each column of <code>X2</code>.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>Only use this method if <code>X1</code> and <code>X2</code> are distinct (no overlapping columns). For <code>X2</code> consisting of a subset of columns with indices <code>idx</code>, use <code>findr(X1; cols=idx)</code> instead. </p><p>See also <a href="#BioFindr.findr-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame"><code>findr(::DataFrame)</code></a>, <a href="../utils/#BioFindr.symprobs"><code>symprobs</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L111-L121">source</a></section><section><div><pre><code class="language-julia hljs">findr(X::Matrix{T},G::Array{S}; method=&quot;moments&quot;) where {T&lt;:AbstractFloat, S&lt;:Integer}</code></pre><p>Compute posterior probabilities for nonzero differential expression of colunns of input matrix <code>X</code> across groups defined by one or more categorical variables (columns of <code>G</code>).</p><p>Return a matrix of size ncols(X) x ncols(G)</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::DataFrame,::DataFrame)</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>G</code> is currently assumed to be an array (vector or matrix) of integers. CategoricalArrays will be supported in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L141-L154">source</a></section><section><div><pre><code class="language-julia hljs">findr(dX::T, dG::T; method=&quot;moments&quot;, FDR=1.0, sorted=true) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX), Matrix(dG))</code> when the inputs <code>dX</code> and <code>dG</code> are in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code> (Posterior) <code>Probability</code>, and <code>qvalue</code> columns.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX</code>) (<code>sorted=false</code>)</p><p>Note that depending on the type of <code>Matrix(dG)</code>, different matrix-based methods are called. If <code>Matrix(dG)</code> consists of Floats, posterior probabilities for nonzero pairwise correlations between the variables in <code>dG</code> and variables in <code>dX</code> are computed. If <code>Matrix(dG)</code> consists of integers, posterior probabilities for nonzero differential expression of variables in <code>dX</code> across groups defined by the variables in <code>dG</code> are computed</p><p>See also [<code>findr(::Matrix,::Array)</code>], <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L168-L182">source</a></section><section><div><pre><code class="language-julia hljs">findr(X::Matrix{T},G::Matrix{S},pairGX::Matrix{S}; method=&quot;moments&quot;, combination=&quot;none&quot;) where {T&lt;:AbstractFloat, S&lt;:Integer}</code></pre><p>Compute posterior probabilities for nonzero causal relations between columns of input matrix <code>X</code>. The probabilities are estimated for relations going from a subset of columns of <code>X</code> that have a (discrete) instrumental variable in input matrix <code>G</code> to all columns of <code>X</code>, while excluding self-interactions (given default value 1). The matching between columns of <code>X</code> and columns of <code>G</code> is given by <code>pairGX</code>, a two-column array where the first column corresponds to a column index in <code>G</code> and the second to a column index in <code>X</code>.</p><p>Posterior probabilities are computed for the following tests</p><ul><li>Test 2 (<strong>Linkage test</strong>) </li><li>Test 3 (<strong>Mediation test</strong>)</li><li>Test 4 (<strong>Relevance test</strong>)</li><li>Test 5 (<strong>Pleiotropy test</strong>)</li></ul><p>which can be combined into the mediation test (<span>$P_2 P_3$</span>; <code>combination=&quot;mediation&quot;</code>), the instrumental variable or non-independence test (<span>$P_2 P_5$</span>; <code>combination=&quot;IV&quot;</code>), or BioFindr&#39;s original combination (<span>$\frac{1}{2}(P_2 P_5 + P_4)$</span>; <code>combination=&quot;orig&quot;</code>). By default, individual probability matrices for all tests are returned (<code>combination=&quot;none&quot;</code>).</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>If <code>combination=&quot;none&quot;</code>, then the output has size ncols(X) x 4 x ncols(G), where the middle index indexes the tests, and otherwise the output has size ncols(X) x ncols(G). </p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::DataFrame,::DataFrame,::DataFrame)</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>G</code> is currently assumed to be an array (vector or matrix) of integers. I intend to use CategoricalArrays in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L194-L216">source</a></section><section><div><pre><code class="language-julia hljs">findr(dX::T, dG::T, dE::T; colX=2, colG=1, method=&quot;moments&quot;, combination=&quot;IV&quot;, FDR=1.0, sorted=true) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX), Matrix(dG), pairGX)</code> when the inputs are in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code> (Posterior) <code>Probability</code>, and <code>qvalue</code> columns. When DataFrames are used, only combined posterior probabilities can be returned (<code>combination=&quot;IV&quot;</code> (default), <code>&quot;mediation&quot;</code>, or <code>&quot;orig&quot;</code>).</p><p>The input dataframes are:</p><ul><li><code>dX</code> - DataFrame with expression data, columns are genes</li><li><code>dG</code> - DataFrame with genotype data, columns are variants (SNPs)</li><li><code>dE</code> - DataFrame with eQTL results, must contain columns with gene and SNP IDs that can be mapped to column names in <code>dX</code> and <code>dG</code>, respectively</li><li><code>colG</code> - name or number of variant ID column in <code>dE</code>, default 1</li><li><code>colX</code> - name or number of gene ID column in <code>dE</code>, default 2</li></ul><p>The numeric mapping between column indices in <code>Matrix(dG)</code> and <code>Matrix(dX)</code> is obtained from these inputs using the <a href="../utils/#BioFindr.getpairs"><code>getpairs</code></a> function.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX</code>) (<code>sorted=false</code>)</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::Matrix,::Array,::Matrix)</code></a>, <a href="../utils/#BioFindr.getpairs"><code>getpairs</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>, <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L235-L257">source</a></section><section><div><pre><code class="language-julia hljs">findr(X1::Matrix{T},X2::Array{T},G::Array{S},pairGX::Matrix{R}; method=&quot;moments&quot;, combination=&quot;none&quot;)  where {T&lt;:AbstractFloat, S&lt;:Integer}</code></pre><p>Compute posterior probabilities for nonzero causal relations from columns of input matrix <code>X2</code> to columns of input matrix <code>X1</code>. The probabilities are estimated for a subset of columns of <code>X2</code> that have a (discrete) instrumental variable in input matrix <code>G</code>. The matching between columns of <code>X2</code> and columns of <code>G</code> is given by <code>pairGX</code>, a two-column array where the first column corresponds to a column index in <code>G</code> and the second to a column index in <code>X2</code>.</p><p>Posterior probabilities are computed for the following tests</p><ul><li>Test 2 (<strong>Linkage test</strong>) </li><li>Test 3 (<strong>Mediation test</strong>)</li><li>Test 4 (<strong>Relevance test</strong>)</li><li>Test 5 (<strong>Pleiotropy test</strong>)</li></ul><p>which can be combined into the mediation test (<span>$P_2 P_3$</span>; <code>combination=&quot;mediation&quot;</code>), the instrumental variable or non-independence test (<span>$P_2 P_5$</span>; <code>combination=&quot;IV&quot;</code>), or BioFindr&#39;s original combination (<span>$\frac{1}{2}(P_2 P_5 + P_4)$</span>; <code>combination=&quot;orig&quot;</code>). By default, individual probability matrices for all tests are returned (<code>combination=&quot;none&quot;</code>).</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>If <code>combination=&quot;none&quot;</code>, then the output has size ncols(X1) x 4 x ncols(X2), where the middle index indexes the tests, and otherwise the output has size ncols(X1) x ncols(X2).</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::DataFrame,::DataFrame,::DataFrame,::DataFrame)</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>, <a href="../inference/#BioFindr.supernormalize"><code>supernormalize</code></a>, <a href="../posteriorprobs/#BioFindr.pprob_col"><code>pprob_col</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>G</code> is currently assumed to be an array (vector or matrix) of integers. I intend to use CategoricalArrays in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L276-L298">source</a></section><section><div><pre><code class="language-julia hljs">findr(dX1::T, dX2::T, dG::T, dE::T; colG=1, colX=2, method=&quot;moments&quot;, combination=&quot;IV&quot;, FDR=1.0, sorted=true) where T&lt;:AbstractDataFrame</code></pre><p>Wrapper for <code>findr(Matrix(dX1), Matrix(dX2), Matrix(dG), pairGX2)</code> when the inputs <code>dX1</code>, <code>dX2</code>, and <code>dG</code> are in the form of a DataFrame. The output is then also wrapped in a DataFrame with <code>Source</code>, <code>Target</code>, (Posterior) <code>Probability</code>, and <code>qvalue</code> columns. When DataFrames are used, only combined posterior probabilities can be returned (<code>combination=&quot;IV&quot;</code> (default), <code>&quot;mediation&quot;</code>, or <code>&quot;orig&quot;</code>).</p><p>The numeric mapping between column indices in <code>Matrix(dG)</code> and <code>Matrix(dX2)</code> is obtained from the DataFrame inputs using the <a href="../utils/#BioFindr.getpairs"><code>getpairs</code></a> function.</p><p>The optional parameter <code>method</code> determines the LLR mixture distribution fitting method and can be either <code>moments</code> (default) for the method of moments, or <code>kde</code> for kernel-based density estimation.</p><p>The optional parameter <code>FDR</code> can be used to return only a subset of interactions with a desired expected FDR value (q-value threshold) (default 1.0, no filtering).</p><p>The optional parameter <code>sorted</code> determines if the output must be sorted by increasing q-value / decreasing posterior probability (<code>sorted=true</code>, the default) or by causal factor (column names of <code>dX2</code>) (<code>sorted=false</code>)</p><p>See also <a href="#BioFindr.findr-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>findr(::Matrix,::Array,::Array,::Matrix)</code></a>, <a href="../utils/#BioFindr.combineprobs"><code>combineprobs</code></a>, <a href="../utils/#BioFindr.stackprobs"><code>stackprobs</code></a>, <a href="../utils/#BioFindr.globalfdr!"><code>globalfdr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmichoel/BioFindr.jl/blob/136b37be215acf718f03332bbf32392d6bf7cebf/src/BioFindr.jl#L319-L333">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Chen2007"><a class="tag is-link" href="#citeref-Chen2007">Chen2007</a>Chen L, Emmert-Streib F, Storey J. <a href="https://doi.org/10.1186/gb-2007-8-10-r219">Harnessing naturally randomized transcription to infer regulatory relationships among genes</a>. Genome Biol 8, R219 (2007).</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../posteriorprobs/">« Bayesian inference of posterior probabilities</a><a class="docs-footer-nextpage" href="../utils/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 February 2024 09:08">Tuesday 6 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
